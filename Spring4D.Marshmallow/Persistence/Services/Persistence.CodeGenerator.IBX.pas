unit Persistence.CodeGenerator.IBX;

interface

uses
  System.Classes,
  IBX.IBDatabase,
  IBX.IBCustomDataSet,
  Persistence.CodeGenerator.Abstract,
  Spring.Persistence.Mapping.CodeGenerator.Abstract;

{$M+}

type
  TCodeGeneratorIBX = class(TCodeGenerator<TIBDataBase>)
  private const
    StatementForAllPrimaryKey =
        'SELECT '
      + '    RC.RDB$RELATION_NAME AS TABLENAME, '
      + '    SG.RDB$FIELD_NAME AS FIELDNAME, '
      + '    IX.RDB$INDEX_NAME AS INDEXNAME '
      + 'FROM '
      + '    RDB$INDICES IX '
      + '    LEFT JOIN RDB$INDEX_SEGMENTS SG ON IX.RDB$INDEX_NAME = SG.RDB$INDEX_NAME '
      + '    LEFT JOIN RDB$RELATION_CONSTRAINTS RC ON RC.RDB$INDEX_NAME = IX.RDB$INDEX_NAME '
      + 'WHERE '
      + '    RC.RDB$CONSTRAINT_TYPE = ''PRIMARY KEY''';

  private const
    StatementForFields =
        'SELECT '
      + '  R.RDB$FIELD_NAME, '
      + '  F.RDB$FIELD_LENGTH, '
      + '  F.RDB$FIELD_SCALE, '
      + '  F.RDB$FIELD_TYPE, '
      + '  CASE F.RDB$FIELD_TYPE '
      + '    WHEN ''7'' THEN ''SMALLINT'' '
      + '    WHEN ''8'' THEN ''INTEGER'' '
      + '    WHEN ''10'' THEN ''FLOAT'' '
      + '    WHEN ''12'' THEN ''DATE'' '
      + '    WHEN ''13'' THEN ''TIME'' '
      + '    WHEN ''14'' THEN ''CHAR'' '
      + '    WHEN ''16'' THEN ''BIGINT'' '
      + '    WHEN ''27'' THEN ''DOUBLE PRECISION'' '
      + '    WHEN ''35'' THEN ''TIMESTAMP'' '
      + '    WHEN ''37'' THEN ''VARCHAR'' '
      + '    WHEN ''261'' THEN ''BLOB'' '
      + '    ELSE F.RDB$FIELD_TYPE '
      + '  END FieldTypDescription '
      + 'FROM '
      + '  RDB$RELATION_FIELDS R '
      + '  LEFT JOIN RDB$FIELDS F ON  F.RDB$FIELD_NAME = R.RDB$FIELD_SOURCE '
      + '  LEFT JOIN RDB$TYPES T ON T.RDB$TYPE = F.RDB$FIELD_TYPE '
      + 'WHERE '
      + '  R.RDB$RELATION_NAME = ''CUSTOMER'' AND T.RDB$FIELD_NAME = ''RDB$FIELD_TYPE'' '
      + 'ORDER BY '
      + '  R.RDB$FIELD_POSITION; ';
  strict private
    FPrimaryKeys: TStringList;
  private
    function GetIBDataSet(const AStatement: string): TIBDataSet;

    procedure GeneratorColumns(const ATablename: string; const AEntityData: TEntityModelData);

    procedure FindAllAllPrimaryKeys();
    procedure InnerGenerator();
  public
    constructor Create;
    destructor Destroy; override;

    procedure Generate(); override;
  end;

{$M-}

implementation

uses
  System.SysUtils,
  Spring.Persistence.Mapping.CodeGenerator;

{ TCodeGeneratorIBX<TIBDataBase> }

constructor TCodeGeneratorIBX.Create;
begin
  inherited;
  FPrimaryKeys := TStringList.Create;
end;

destructor TCodeGeneratorIBX.Destroy;
begin
  FPrimaryKeys.Free;
  inherited;
end;

procedure TCodeGeneratorIBX.Generate();
begin
  inherited;
  FindAllAllPrimaryKeys;
  InnerGenerator;
end;

procedure TCodeGeneratorIBX.GeneratorColumns;
var
  LDataSet: TIBDataSet;
  LColumn: TColumnData;
begin
  LDataSet := GetIBDataSet(Format(StatementForFields, [ATablename]));
  try
    while not LDataSet.Eof do
    begin
      LColumn := TColumnData.Create;
      LColumn.ColumnName := LDataSet.Fields[0].AsString.Trim;
      LColumn.ColumnTypeName := LDataSet.Fields[4].AsString.Trim;

      if (LDataSet.Fields[3].AsInteger = 14)
      or (LDataSet.Fields[3].AsInteger = 37) then
        LColumn.ColumnLength := LDataSet.Fields[1].AsInteger;

      if (FPrimaryKeys.IndexOf(ATablename + LDataSet.Fields[0].AsString.Trim) > 0) then
      begin
        //  Only my variant, has to be adapted if necessary...
        LColumn.IsAutogenerated := True;
        LColumn.IsPrimaryKey := True;
        LColumn.IsRequired := True;
        LColumn.NotNull := True;
      end;

      AEntityData.Columns.Add(LColumn);
      LDataSet.Next;
    end;
  finally
    LDataSet.Free();
  end;
end;

function TCodeGeneratorIBX.GetIBDataSet(const AStatement: string): TIBDataSet;
begin
  Result := TIBDataSet.Create(nil);
  Result.Database := Database;
  Result.Transaction := Database.Transactions[Database.TransactionCount - 1];
  Result.SelectSQL.Text := AStatement;
  Result.Open();
  Result.First;
end;

procedure TCodeGeneratorIBX.FindAllAllPrimaryKeys;
var
  LDataSet: TIBDataSet;
begin
  LDataSet := GetIBDataSet(StatementForAllPrimaryKey);
  try
    while not LDataSet.Eof do
    begin
      FPrimaryKeys.Add(LDataSet.Fields[0].AsString.Trim + LDataSet.Fields[1].AsString.Trim);
      LDataSet.Next;
    end;
  finally
    LDataSet.Free();
  end;
end;

procedure TCodeGeneratorIBX.InnerGenerator;
var
  LEachTable: string;
  LTables: TStringList;
  LEntityData: TEntityModelData;
  LGenerator: TDelphiUnitCodeGenerator;
begin
  LGenerator := TDelphiUnitCodeGenerator.Create;
  LTables := TStringList.Create;
  try
    Database.GetTableNames(LTables);
    for LEachTable in LTables do
    begin
      LEntityData := TEntityModelData.Create;
      try
        LEntityData.TableName := LEachTable;
        GeneratorColumns(LEachTable, LEntityData);

        TablesWithField.Add(LEachTable, LGenerator.Generate(LEntityData));
      finally
        LEntityData.Free;
      end;
    end;
  finally
    LGenerator.Free;
    LTables.Free;
  end;
end;

end.

