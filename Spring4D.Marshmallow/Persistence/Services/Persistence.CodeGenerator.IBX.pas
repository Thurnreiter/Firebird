unit Persistence.CodeGenerator.IBX;

interface

uses
  System.Generics.Collections,
  IBX.IBDatabase,
  Persistence.CodeGenerator.Abstract,
  Spring.Persistence.Mapping.CodeGenerator.Abstract;

{$M+}

type
  TCodeGeneratorIBX = class(TCodeGenerator<TIBDataBase>)
  private const
    StatementForFields =
        'SELECT '
      + '  R.RDB$FIELD_NAME FieldName, '
      + '  RDB$TYPE_NAME TypeName, '
      + '  RDB$FIELD_LENGTH FieldLength, '
      + '  RDB$FIELD_SCALE FieldScale, '
      + '  RDB$FIELD_TYPE FieldType, '
      + '  CASE RDB$FIELD_TYPE '
      + '    WHEN ''7'' THEN ''SMALLINT'' '
      + '    WHEN ''8'' THEN ''INTEGER'' '
      + '    WHEN ''10'' THEN ''FLOAT'' '
      + '    WHEN ''12'' THEN ''DATE'' '
      + '    WHEN ''13'' THEN ''TIME'' '
      + '    WHEN ''14'' THEN ''CHAR'' '
      + '    WHEN ''16'' THEN ''BIGINT'' '
      + '    WHEN ''27'' THEN ''DOUBLE PRECISION'' '
      + '    WHEN ''35'' THEN ''TIMESTAMP'' '
      + '    WHEN ''37'' THEN ''VARCHAR'' '
      + '    WHEN ''261'' THEN ''BLOB'' '
      + '    ELSE  RDB$FIELD_TYPE '
      + '  END FieldTypDescription, '
      + '  RC.RDB$CONSTRAINT_TYPE '
      + 'FROM '
      + '    RDB$RELATION_FIELDS R '
      + '    JOIN RDB$FIELDS F ON  F.RDB$FIELD_NAME = R.RDB$FIELD_SOURCE '
      + '    INNER JOIN RDB$TYPES T ON T.RDB$TYPE = F.RDB$FIELD_TYPE '
      + '    LEFT JOIN RDB$INDEX_SEGMENTS SG ON SG.RDB$FIELD_NAME = R.RDB$FIELD_NAME '
      + '    LEFT JOIN RDB$RELATION_CONSTRAINTS RC ON RC.RDB$INDEX_NAME = SG.RDB$INDEX_NAME AND RC.rdb$constraint_type = ''PRIMARY KEY'' '

      + 'WHERE '
      + '    R.RDB$RELATION_NAME = ''%s'' AND T.RDB$FIELD_NAME = ''RDB$FIELD_TYPE'' '
      + 'ORDER BY '
      + '    R.RDB$FIELD_POSITION; ';
  private
    procedure GeneratorColumns(const ATablename: string; const AEntityData: TEntityModelData);
    procedure InnerGenerator();
  public
    procedure Generate(); override;
  end;

{$M-}

implementation

uses
  System.Classes,
  System.SysUtils,
  IBX.IBCustomDataSet,
  Spring.Persistence.Mapping.CodeGenerator;

{ TCodeGeneratorIBX<TIBDataBase> }

procedure TCodeGeneratorIBX.Generate();
begin
  inherited;
  InnerGenerator;
end;

procedure TCodeGeneratorIBX.GeneratorColumns;
var
  LDataSet: TIBDataSet;
  LColumn: TColumnData;
begin
  LDataSet := TIBDataSet.Create(nil);
  try
    LDataSet.Database := Database;
    LDataSet.Transaction := Database.Transactions[Database.TransactionCount - 1];
    LDataSet.SelectSQL.Text := Format(StatementForFields, [ATablename]);
    LDataSet.Open();
    LDataSet.First;
    while not LDataSet.Eof do
    begin
      LColumn := TColumnData.Create;
      LColumn.ColumnName := LDataSet.Fields[0].AsString.Trim;
      LColumn.ColumnTypeName := LDataSet.Fields[5].AsString.Trim;

      if (LDataSet.Fields[4].AsInteger = 14)
      or (LDataSet.Fields[4].AsInteger = 37) then
        LColumn.ColumnLength := LDataSet.Fields[2].AsInteger;

      if (not LDataSet.Fields[6].AsString.IsEmpty) then
      begin
        LColumn.IsAutogenerated := True;
        LColumn.IsPrimaryKey := True;
        LColumn.IsRequired := True;
        LColumn.NotNull := True;
      end;

      AEntityData.Columns.Add(LColumn);
      LDataSet.Next;
    end;
  finally
    LDataSet.Free();
  end;
end;

procedure TCodeGeneratorIBX.InnerGenerator;
var
  LEachTable: string;
  LTables: TStringList;
  LEntityData: TEntityModelData;
  LGenerator: TDelphiUnitCodeGenerator;
begin
  LGenerator := TDelphiUnitCodeGenerator.Create;
  LTables := TStringList.Create;
  try
    Database.GetTableNames(LTables);
    for LEachTable in LTables do
    begin
      LEntityData := TEntityModelData.Create;
      try
        LEntityData.TableName := LEachTable;
        GeneratorColumns(LEachTable, LEntityData);

        TablesWithField.Add(LEachTable, LGenerator.Generate(LEntityData));
      finally
        LEntityData.Free;
      end;
    end;
  finally
    LGenerator.Free;
    LTables.Free;
  end;
end;

end.

